import {
  Controller,
  Delete,
  ForbiddenException,
  Get,
  HttpCode,
  HttpStatus,
  INestApplication,
  Patch,
  Post,
  Put,
  UnauthorizedException,
  Headers,
  Query
} from "@nestjs/common";
import {Test} from "@nestjs/testing";
import {CoreTestingModule} from "@spica-server/core/testing";
import {BatchModule} from "@spica-server/batch";
import {PassportTestingModule} from "@spica-server/passport/testing";
import axios, {AxiosInstance} from "axios";

const PORT = "4300";

@Controller("ctrl1")
export class Controller1 {
  @Get()
  find(@Query("filter") filters: string | string[]) {
    filters = Array.isArray(filters) ? filters : !filters ? [] : [filters];

    let docs = ["doc1", "doc2"];

    if (filters.length) {
      docs = docs.filter(doc => filters.includes(doc));
    }

    return docs;
  }

  @Post()
  insert() {
    return {title: "inserted_doc"};
  }

  @Put()
  replace() {
    return {title: "replaced_doc"};
  }

  @Patch()
  patch() {
    return {title: "patched_doc"};
  }

  @Delete()
  @HttpCode(HttpStatus.NO_CONTENT)
  delete() {}

  @Get("auth")
  auth(@Headers("Authorization") auth: string) {
    if (!auth) {
      throw new UnauthorizedException();
    } else if (auth == "user") {
      throw new ForbiddenException();
    }
  }
}

describe("Integration tests", () => {
  let httpService: AxiosInstance;
  let app: INestApplication;

  beforeAll(async () => {
    const module = await Test.createTestingModule({
      imports: [
        CoreTestingModule,
        BatchModule.forRoot({port: PORT}),
        PassportTestingModule.initialize()
      ],
      controllers: [Controller1]
    }).compile();

    app = module.createNestApplication();
    await app.listen(PORT);

    httpService = axios.create({
      baseURL: `http://localhost:${PORT}`
    });
  });

  afterAll(() => app.close());

  describe("http requests", () => {
    it("should send http requests", async () => {
      const getRequest = {
        url: "ctrl1",
        method: "GET",
        headers: {},
        id: "1"
      };

      const getWithFilterRequest = {
        url: "ctrl1?filter=doc1",
        method: "GET",
        headers: {},
        id: "2"
      };

      const getWithFiltersRequest = {
        url: "ctrl1?filter=doc1&filter=doc2",
        method: "GET",
        headers: {},
        id: "3"
      };
      const postRequest = {
        url: "ctrl1",
        method: "POST",
        body: {hello: "hi"},
        headers: {},
        id: "4"
      };
      const putRequest = {
        url: "ctrl1",
        method: "PUT",
        body: {hello: "hi"},
        headers: {},
        id: "5"
      };

      const patchRequest = {
        url: "ctrl1",
        method: "PATCH",
        body: {hello: "hi"},
        headers: {},
        id: "6"
      };

      const deleteRequest = {
        url: "ctrl1",
        method: "DELETE",
        body: {hello: "hi"},
        headers: {},
        id: "7"
      };

      const notFoundRequest = {
        url: "non-existed-url",
        method: "GET",
        headers: {},
        id: "8"
      };

      const unauthenticatedRequest = {
        url: "ctrl1/auth",
        method: "GET",
        headers: {},
        id: "9"
      };

      const unauthorizedRequest = {
        url: "ctrl1/auth",
        method: "GET",
        headers: {
          Authorization: "user"
        },
        id: "10"
      };

      const batch = {
        requests: [
          getRequest,
          getWithFilterRequest,
          getWithFiltersRequest,
          postRequest,
          putRequest,
          patchRequest,
          deleteRequest,
          notFoundRequest,
          unauthenticatedRequest,
          unauthorizedRequest
        ]
      };

      const batchResponse = await httpService.post("batch", batch);
      expect(batchResponse.status).toEqual(201);
      expect(batchResponse.statusText).toEqual("Created");

      // hard to guess headers since it's generated by axios,
      // and includes some time specific values
      expect(batchResponse.data.responses[0].headers).toBeDefined();
      batchResponse.data.responses = batchResponse.data.responses.map(r => {
        delete r.headers;
        return r;
      });

      expect(batchResponse.data).toEqual({
        responses: [
          {
            id: "1",
            status: 200,
            body: ["doc1", "doc2"]
          },
          {
            id: "2",
            status: 200,
            body: ["doc1"]
          },
          {
            id: "3",
            status: 200,
            body: ["doc1", "doc2"]
          },
          {
            id: "4",
            status: 201,
            body: {title: "inserted_doc"}
          },
          {
            id: "5",
            status: 200,
            body: {title: "replaced_doc"}
          },
          {
            id: "6",
            status: 200,
            body: {title: "patched_doc"}
          },
          {
            id: "7",
            status: 204,
            body: ""
          },
          {
            id: "8",
            status: 404,
            body: {
              message: "Cannot GET /non-existed-url",
              error: "Not Found",
              statusCode: 404
            }
          },
          {
            id: "9",
            status: 401,
            body: {message: "Unauthorized", statusCode: 401}
          },
          {
            id: "10",
            status: 403,
            body: {message: "Forbidden", statusCode: 403}
          }
        ]
      });
    });
  });

  describe("errors", () => {
    it("should throw validation error if no request provided", async () => {
      const r = await httpService.post("/batch").catch(e => e.response);
      expect(r.status).toEqual(400);
      expect(r.data.message).toContain("must have required property 'requests'");
    });

    it("should throw validation error if request length is zero", async () => {
      const r = await httpService.post("/batch", {requests: []}).catch(e => e.response);
      expect(r.status).toEqual(400);
      expect(r.data.message).toContain(".requests must NOT have fewer than 1 items");
    });

    it("should throw validation error if request method is not supported", async () => {
      const r = await httpService
        .post("/batch", {requests: [{id: "1", method: "OPTIONS", url: "test"}]})
        .catch(e => e.response);
      expect(r.status).toEqual(400);
      expect(r.data.message).toContain(
        ".requests.0.method must be equal to one of the allowed values"
      );
    });

    it("should throw validation error if concurreny is negative", async () => {
      const r = await httpService
        .post("/batch", {requests: [{id: "1", method: "GET", url: "test"}], concurrency: -1})
        .catch(e => e.response);
      expect(r.status).toEqual(400);
      expect(r.data.message).toContain(".concurrency must be >= 0");
    });

    it("should throw validation error if additional property provided", async () => {
      const r = await httpService
        .post("/batch", {requests: [{}], additional: "me"})
        .catch(e => e.response);
      expect(r.status).toEqual(400);
      expect(r.data.message).toContain("must NOT have additional properties 'additional'");
    });
  });
});
