/**
 * Hand-written protobuf TS for AgentTool.
 * Follows the same pattern as rabbitmq.ts generated by protoc-gen-ts.
 * source: agent_tool.proto
 */
import * as pb_1 from "google-protobuf";
import * as grpc_1 from "@grpc/grpc-js";
export namespace AgentTool {
  export class Message extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(
      data?:
        | any[]
        | {
            id?: string;
            tool_name?: string;
            arguments?: Uint8Array;
            result?: Uint8Array;
            error?: Uint8Array;
          }
    ) {
      super();
      pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
      if (!Array.isArray(data) && typeof data == "object") {
        if ("id" in data && data.id != undefined) {
          this.id = data.id;
        }
        if ("tool_name" in data && data.tool_name != undefined) {
          this.tool_name = data.tool_name;
        }
        if ("arguments" in data && data.arguments != undefined) {
          this.arguments = data.arguments;
        }
        if ("result" in data && data.result != undefined) {
          this.result = data.result;
        }
        if ("error" in data && data.error != undefined) {
          this.error = data.error;
        }
      }
    }
    get id() {
      return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
    }
    set id(value: string) {
      pb_1.Message.setField(this, 1, value);
    }
    get tool_name() {
      return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
    }
    set tool_name(value: string) {
      pb_1.Message.setField(this, 2, value);
    }
    get arguments() {
      return pb_1.Message.getFieldWithDefault(this, 3, new Uint8Array(0)) as Uint8Array;
    }
    set arguments(value: Uint8Array) {
      pb_1.Message.setField(this, 3, value);
    }
    get result() {
      return pb_1.Message.getFieldWithDefault(this, 4, new Uint8Array(0)) as Uint8Array;
    }
    set result(value: Uint8Array) {
      pb_1.Message.setField(this, 4, value);
    }
    get error() {
      return pb_1.Message.getFieldWithDefault(this, 5, new Uint8Array(0)) as Uint8Array;
    }
    set error(value: Uint8Array) {
      pb_1.Message.setField(this, 5, value);
    }
    static fromObject(data: {
      id?: string;
      tool_name?: string;
      arguments?: Uint8Array;
      result?: Uint8Array;
      error?: Uint8Array;
    }): Message {
      const message = new Message({});
      if (data.id != null) {
        message.id = data.id;
      }
      if (data.tool_name != null) {
        message.tool_name = data.tool_name;
      }
      if (data.arguments != null) {
        message.arguments = data.arguments;
      }
      if (data.result != null) {
        message.result = data.result;
      }
      if (data.error != null) {
        message.error = data.error;
      }
      return message;
    }
    toObject() {
      const data: {
        id?: string;
        tool_name?: string;
        arguments?: Uint8Array;
        result?: Uint8Array;
        error?: Uint8Array;
      } = {};
      if (this.id != null) {
        data.id = this.id;
      }
      if (this.tool_name != null) {
        data.tool_name = this.tool_name;
      }
      if (this.arguments != null) {
        data.arguments = this.arguments;
      }
      if (this.result != null) {
        data.result = this.result;
      }
      if (this.error != null) {
        data.error = this.error;
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.id.length) writer.writeString(1, this.id);
      if (this.tool_name.length) writer.writeString(2, this.tool_name);
      if (this.arguments.length) writer.writeBytes(3, this.arguments);
      if (this.result.length) writer.writeBytes(4, this.result);
      if (this.error.length) writer.writeBytes(5, this.error);
      if (!w) return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Message {
      const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
        message = new Message();
      while (reader.nextField()) {
        if (reader.isEndGroup()) break;
        switch (reader.getFieldNumber()) {
          case 1:
            message.id = reader.readString();
            break;
          case 2:
            message.tool_name = reader.readString();
            break;
          case 3:
            message.arguments = reader.readBytes();
            break;
          case 4:
            message.result = reader.readBytes();
            break;
          case 5:
            message.error = reader.readBytes();
            break;
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): Message {
      return Message.deserialize(bytes);
    }
  }
  export namespace Message {
    export class Pop extends pb_1.Message {
      #one_of_decls: number[][] = [];
      constructor(
        data?:
          | any[]
          | {
              id?: string;
            }
      ) {
        super();
        pb_1.Message.initialize(
          this,
          Array.isArray(data) ? data : [],
          0,
          -1,
          [],
          this.#one_of_decls
        );
        if (!Array.isArray(data) && typeof data == "object") {
          if ("id" in data && data.id != undefined) {
            this.id = data.id;
          }
        }
      }
      get id() {
        return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
      }
      set id(value: string) {
        pb_1.Message.setField(this, 1, value);
      }
      static fromObject(data: {id?: string}): Pop {
        const message = new Pop({});
        if (data.id != null) {
          message.id = data.id;
        }
        return message;
      }
      toObject() {
        const data: {
          id?: string;
        } = {};
        if (this.id != null) {
          data.id = this.id;
        }
        return data;
      }
      serialize(): Uint8Array;
      serialize(w: pb_1.BinaryWriter): void;
      serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.id.length) writer.writeString(1, this.id);
        if (!w) return writer.getResultBuffer();
      }
      static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Pop {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
          message = new Pop();
        while (reader.nextField()) {
          if (reader.isEndGroup()) break;
          switch (reader.getFieldNumber()) {
            case 1:
              message.id = reader.readString();
              break;
            default:
              reader.skipField();
          }
        }
        return message;
      }
      serializeBinary(): Uint8Array {
        return this.serialize();
      }
      static deserializeBinary(bytes: Uint8Array): Pop {
        return Pop.deserialize(bytes);
      }
    }
    export class Result extends pb_1.Message {
      #one_of_decls: number[][] = [];
      constructor(data?: any[] | {}) {
        super();
        pb_1.Message.initialize(
          this,
          Array.isArray(data) ? data : [],
          0,
          -1,
          [],
          this.#one_of_decls
        );
        if (!Array.isArray(data) && typeof data == "object") {
        }
      }
      static fromObject(data: {}): Result {
        const message = new Result({});
        return message;
      }
      toObject() {
        const data: {} = {};
        return data;
      }
      serialize(): Uint8Array;
      serialize(w: pb_1.BinaryWriter): void;
      serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (!w) return writer.getResultBuffer();
      }
      static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Result {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
          message = new Result();
        while (reader.nextField()) {
          if (reader.isEndGroup()) break;
          switch (reader.getFieldNumber()) {
            default:
              reader.skipField();
          }
        }
        return message;
      }
      serializeBinary(): Uint8Array {
        return this.serialize();
      }
      static deserializeBinary(bytes: Uint8Array): Result {
        return Result.deserialize(bytes);
      }
    }
  }
  interface GrpcUnaryServiceInterface<P, R> {
    (
      message: P,
      metadata: grpc_1.Metadata,
      options: grpc_1.CallOptions,
      callback: grpc_1.requestCallback<R>
    ): grpc_1.ClientUnaryCall;
    (
      message: P,
      metadata: grpc_1.Metadata,
      callback: grpc_1.requestCallback<R>
    ): grpc_1.ClientUnaryCall;
    (
      message: P,
      options: grpc_1.CallOptions,
      callback: grpc_1.requestCallback<R>
    ): grpc_1.ClientUnaryCall;
    (message: P, callback: grpc_1.requestCallback<R>): grpc_1.ClientUnaryCall;
  }
  export abstract class UnimplementedQueueService {
    static definition = {
      pop: {
        path: "/AgentTool.Queue/pop",
        requestStream: false,
        responseStream: false,
        requestSerialize: (message: Message.Pop) => Buffer.from(message.serialize()),
        requestDeserialize: (bytes: Buffer) => Message.Pop.deserialize(new Uint8Array(bytes)),
        responseSerialize: (message: Message) => Buffer.from(message.serialize()),
        responseDeserialize: (bytes: Buffer) => Message.deserialize(new Uint8Array(bytes))
      },
      respond: {
        path: "/AgentTool.Queue/respond",
        requestStream: false,
        responseStream: false,
        requestSerialize: (message: Message) => Buffer.from(message.serialize()),
        requestDeserialize: (bytes: Buffer) => Message.deserialize(new Uint8Array(bytes)),
        responseSerialize: (message: Message.Result) => Buffer.from(message.serialize()),
        responseDeserialize: (bytes: Buffer) => Message.Result.deserialize(new Uint8Array(bytes))
      }
    };
    [method: string]: grpc_1.UntypedHandleCall;
    abstract pop(
      call: grpc_1.ServerUnaryCall<Message.Pop, Message>,
      callback: grpc_1.sendUnaryData<Message>
    ): void;
    abstract respond(
      call: grpc_1.ServerUnaryCall<Message, Message.Result>,
      callback: grpc_1.sendUnaryData<Message.Result>
    ): void;
  }
  export class QueueClient extends grpc_1.makeGenericClientConstructor(
    UnimplementedQueueService.definition,
    "Queue",
    {}
  ) {
    constructor(
      address: string,
      credentials: grpc_1.ChannelCredentials,
      options?: Partial<grpc_1.ChannelOptions>
    ) {
      super(address, credentials, options);
    }
    pop: GrpcUnaryServiceInterface<Message.Pop, Message> = (
      message: Message.Pop,
      metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<Message>,
      options?: grpc_1.CallOptions | grpc_1.requestCallback<Message>,
      callback?: grpc_1.requestCallback<Message>
    ): grpc_1.ClientUnaryCall => {
      return super.pop(message, metadata, options, callback);
    };
    respond: GrpcUnaryServiceInterface<Message, Message.Result> = (
      message: Message,
      metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<Message.Result>,
      options?: grpc_1.CallOptions | grpc_1.requestCallback<Message.Result>,
      callback?: grpc_1.requestCallback<Message.Result>
    ): grpc_1.ClientUnaryCall => {
      return super.respond(message, metadata, options, callback);
    };
  }
}
